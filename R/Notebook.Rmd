---
title: "Oyster ploidy field study survival analysis"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
  theme: sky
  code_folding: hide
---

Survival analysis to the end of 2023 for oyster ploidy project

## Read in the data and create basic tables and graphs

Load the required packages. Using survival package that was updated in August 2023

```{r, results=FALSE, warning=FALSE, error=FALSE, message=FALSE, }
library(tidyverse)
library(here)
library(survival)
```

Read in the mortality data from the field experiments

```{r}
survdat <- read.csv(here("Data", "MAY_SEPT_2023_MORTSBYBAG.csv"))
```

Correct the data structure

```{r}
survdat <- survdat %>% mutate_at(c("Site", "Bag_Col", "Month", "Bag_no", "Month_no"), as.factor)
str(survdat)
```

Create a new data sheet that calculates the number of survivors at each sampling event (as opposed to the number of moralities)

```{r}
widebagmort <- pivot_wider(survdat[-c(6)], names_from = Month, values_from = Mort_count)
#replace NA in the mortality columns with 0
widebagmort <- widebagmort %>%
  mutate_at(vars(May, June, July, Aug, September), ~replace_na(., 0))
widebagmort$April_survivors <- 50
widebagmort$May_survivors <- widebagmort$April_survivors-widebagmort$May
widebagmort$June_survivors <- widebagmort$May_survivors-widebagmort$June
widebagmort$July_survivors <- widebagmort$June_survivors-widebagmort$July
widebagmort$Aug_survivors <- widebagmort$July_survivors-widebagmort$Aug
widebagmort$Sept_survivors <- widebagmort$Aug_survivors-widebagmort$September

no_survivors <- widebagmort %>% pivot_longer(cols=c(9:14),#######################As months are added make sure their columns are selected - change to an auto thing*************
                                                         names_to='Month_survivor',
                                                         values_to='No_survivors') %>% 
  select("Site", "Bag_Col", "Bag_no",'Month_survivor','No_survivors')
no_survivors$Month_survivor <- as.factor(no_survivors$Month_survivor)
no_survivors
```

Double check that all bags are accounted for. There should be 8 bags per site per sampling event = 48 as of September 2023

```{r, echo=FALSE}
no_survivors %>% group_by(Site, Bag_Col) %>% summarise(nbags=n())
```

Sumarise the number of survivors per site per sampling event

```{r, echo=FALSE}
mean_survival_proportion <- no_survivors %>% 
  group_by(Site, Bag_Col, Month_survivor) %>% 
  summarise(meansurv=mean(No_survivors), semsurv=sd(No_survivors)/sqrt(n()))

mean_survival_proportion
```

Create a basic survival plot taht shows the number of survivors at each sampling event

```{r, echo=FALSE}


mean_survival_proportion %>% ggplot(aes(x=factor(Month_survivor, level=c("April_survivors", 'May_survivors', 'June_survivors', 'July_survivors', 'Aug_survivors', 'Sept_survivors')), ###add new months here**********
             y=meansurv, colour = Bag_Col, group=Bag_Col))+
  scale_x_discrete(labels=c('April', 'May', 'June', 'July', 'August', 'September'))+####################Add new months here ***********************
  scale_color_manual(values=c('blue', 'green', 'red'), name = "Ploidy", labels = c("Diploid", "Induced Triploid", "Mated Triploid"))+
  geom_errorbar(aes(ymin=meansurv-semsurv, ymax=meansurv+semsurv))+
  geom_line()+facet_grid(~Site)+
  xlab("Month")+ylab("Mean number of survivors per bag (Â± SEM)")+
  theme_bw()+ggtitle("Number of survivors since experiment start")
```

## Start survival analyses



The first thing I did was create a constant variable for the number of montly sampling events I have. This just makes my life easier by not constantly changing the number of months I have when I add new data

```{r}
months <- 5#Change with each sampling event
```

Need to turn the data into individual survival data. Each oyster should be listed with either alive or dead at each sampling point. Each oyster will need an ID number. 8 Cages per ploidy per site were monitored for mortality so a total of 400 oysters per ploidy per site at the start. Total of 4800 oysters. 

```{r}
#the uncount function may work here
#Count just the April individuals to get ID numbers for each individual at the start
no_survivorsexpanded_April <- no_survivors %>% filter(Month_survivor == 'April_survivors') %>% #repeats each row by the number of times in April_survivors col
  uncount(No_survivors) 
no_survivorsexpanded_April$BAG_ID <- paste0(no_survivorsexpanded_April$Site, no_survivorsexpanded_April$Bag_Col, no_survivorsexpanded_April$Bag_no, "_")#creates a (non unnique ID) number for each oyster this is not unique becuse I want to match it to my mortality 
#Adds a unique within bag ID number to each oyster in April
no_survivorsexpanded_April$OYS_ID <- rep(1:50, times = nrow(no_survivorsexpanded_April)/50)
no_survivorsexpanded_April$status <- 0 #gives everyone who is alive a status of 0


no_survivorsexpanded_noapril <- no_survivors %>% 
  filter(Month_survivor != "April_survivors") %>% pivot_wider(names_from = Month_survivor, values_from = No_survivors)
no_survivorsexpanded_noapril$BAG_ID <- paste0(no_survivorsexpanded_noapril$Site, no_survivorsexpanded_noapril$Bag_Col, no_survivorsexpanded_noapril$Bag_no, "_") #Give these individuals a bag code thats the same as for april
#take the April DF and join it with filtered DF for each month that has been uncounted
survival_status <- no_survivorsexpanded_April %>% full_join((select(no_survivorsexpanded_noapril, "May_survivors", "BAG_ID") %>% uncount(May_survivors)), by = "BAG_ID")

no_survivorsexpanded_noapril$status <- 0#Gives everyone alive a status 0
no_survivorsexpanded_noapril1 <- no_survivorsexpanded_noapril %>% 
   #Pivot this data wider so that I can do a join

```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
